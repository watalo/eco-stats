# 第13章 平稳时间序列
## 13.1 时间序列的自相关

#定义  k阶自协方差
autocovanriance of oder k
$$\gamma_k\equiv Cov(y_t,y_{t-k})=E[(y_t-\mu)(y_{t-K}-\mu)]$$
- $\mu$ 为总体均值（$E(y)$）
- 反映了同一变量相隔k期之间的自相关程度
- $k=0$ 时，$\gamma_0=Var(y)$
- 估计值为样本自协方差：$$\hat\gamma_k \equiv = \frac{1}{T-k}\sum_{t=1}^{T-k}(y_t-\overline y)(y_{t+k}-\overline y)$$
#定义 k阶自相关系数
autocorrelation of oder k
$$\rho_k \equiv \frac{Cov(y_t,y_{t+k})}{Var(y_t)}$$
- 自相关系数是自协方差的标准化，取值范围[-1,1]
- 估计值为 $$\hat\rho_k \equiv \frac{\hat\gamma_k}{\hat\gamma_0}$$
	- 其中$\hat\rho_0 \equiv \frac{1}{T-1}\sum_{i=1}^T (y_t-\overline y)^2$ 为样本方差

$\rho_k$ 不依赖于具体时间，仅是滞后阶数k的函数，称为<span style="color:#00b0f0">自相关函数（Auto-correlation function，ACF）</span>

（k，$\rho_k$）画出图，称为<span style="color:#00b0f0">自相关图（correlogram）</span>

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sns

data = pd.read_stata('../2_Data/Data-2e/gdp_china.dta')
data['lny'] = np.log(data['y'])
data['dlny']  = data['lny'].diff().dropna()
data['dy'] = (data['y'] - data['y'].shift(1))/data['y'].shift(1)
data.set_index('year', inplace=True)
data.dropna(inplace=True)  

# 时间序列的趋势图
fig = plt.figure(figsize=(8,4))
sns.lineplot(x='year', y='y', data=data)

# 对数时间序列的趋势图
fig = plt.figure(figsize=(8,4))
sns.lineplot(x='year', y='lny', data=data)

# 对比
fig = plt.figure(figsize=(10,4))
sns.lineplot(x='year', y='dlny', data=data)
sns.lineplot(x='year', y='dy', data=data)

# ACF图和PACF图
from cq import acfgram

ac = acfgram(data['dlny'],lags=15)
```
#### 自相关图函数
```python
import pandas as pd
import numpy as np
import statsmodels.api as sm
import seaborn as sns
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

def acfgram(time_series,lags=10):
    '''acgram 绘制时间序列的自相关图和偏自相关图,并返回acf和pacf的结果
        达到类似与其他统计软件一样的效果
    Arguments:
        time_series -- pd.Series,array-like, 时间序列
    Keyword Arguments:
        lags -- int, 最大滞后阶数 (default: {10})
    Returns:
        1.plot:绘制时间序列的序列图、acf图和pacf图
        2.dataframe:返回字段命为lags acf pacf Q和Prob(Q)的数据
            - Q、Prob(Q) -- acf的统计量
    '''

    # 计算自相关系数
    acf_result = sm.tsa.acf(time_series,
                            nlags = lags,
                            qstat=True,
                            fft=False)

    # 计算偏自相关系数
    pacf_result = sm.tsa.pacf(time_series, nlags=lags)
    # 创建DataFrame来存储结果

    result_df = pd.DataFrame({
        'Lags': np.arange(1,lags+1),
        'ACF': acf_result[0][1:],
        'PACF': pacf_result[1:],
        'Q':acf_result[1],
        'Prob(Q)': acf_result[2]  
    })

    # 绘制自相关图
    _, axes = plt.subplots(nrows=3, ncols=1, figsize=(15, 15), dpi=400)
    ## 分别画出3个图
    time_series.plot(ax=axes[0])
    plot_acf(time_series, lags=lags,ax=axes[1])
    plot_pacf(time_series,lags=lags,ax=axes[2])
    ## 设置图标题
    axes[0].set_title('Time-Series')
    axes[1].set_title('Autocorrelation')
    axes[2].set_title('Partial-Autocorrelation')
    plt.show()

    return result_df

```
## 13.2 一阶自回归

用过去值来预测当前值，一阶自回归（AR(1)）
$$y_t = \beta_0+\beta_1 y_{t-1}+\epsilon_t \qquad (t=2,\cdots,n) \tag{13.6}$$
- 扰动项 $\epsilon_t$ 为白噪声
- 扰动项 $\epsilon_t$ 无自相关，意味着任意不同期的扰动项协方差为0，是球形扰动项
- OLS估计是一致的，但损失第一个数据
- 可使用MLE，但需加速扰动项服从正态分布


## 13.3 高阶自回归


## 13.4 自回归分布滞后模型


## 13.5 误差修正模型


## 13.6 移动平均与ARMA模型


## 13.7 脉冲响应函数


## 13.8 向量自回归过程


## 13.9 VAR的脉冲响应函数


## 13.10 格兰杰因果检验


## 13.11 VAR的Stata命令及实例


## 13.12 时间趋势项


## 13.13 季节调整


## 13.14 日期数据的导入




## 本章小结

## 习题